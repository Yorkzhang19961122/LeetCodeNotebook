【题目】

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

【示例】

```C++
输入：n = 3
输出：5
```

---

【[题解思路—DP](https://leetcode-cn.com/problems/unique-binary-search-trees/solution/96-bu-tong-de-er-cha-sou-suo-shu-dong-ta-vn6x/)】

关键是转移方程的推导：

当n=1时，二叉搜索树只有一种：

```
1
```

当n=2时，画出来的二叉搜索树：

```
1           2
 \         /
   2      1
```

当n=3时，画出来的二叉搜索树有5棵：

```
1             1           2          3              3
  \            \        /   \        /             /
   2            3       1    3      2             1
	\          /                    /              \
      3       2                    1                2
```

当1为头结点的时候，其右子树有两个节点，看这两个节点的布局，和 n 为2的时候两棵树的布局是一样的

（我们就是求树的数量，并不用把搜索树都列出来，所以不用关心其具体数值的差异）

当3为头结点的时候，其左子树有两个节点，看这两个节点的布局，和n为2的时候两棵树的布局也是一样的

当2位头结点的时候，其左右子树都只有一个节点，布局和n为1的时候只有一棵树的布局也是一样的

发现到这里，其实就找到的重叠子问题了，其实也就是发现可以通过`dp[1] `和 `dp[2]` 来推导出来`dp[3]`的某种方式。

`dp[3]`，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量:

元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量

元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量

元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

有2个元素的搜索树数量就是`dp[2]`。

有1个元素的搜索树数量就是`dp[1]`。

有0个元素的搜索树数量就是`dp[0]`。

所以`dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]`

【题解代码—DP】

```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1, 0);  // 初始化 dp 数组
        dp[0] = 1;  //初始化0的情况
        for(int i = 0; i <= n; i++) {
            for(int j = 1; j <= i; j++) {
                // 对于第i个节点，需要考虑1作为根节点直到i作为根节点的情况，所以需要累加
                // 一共i个节点，对于根节点j时,左子树的节点个数为j-1，右子树的节点个数为i-j
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
```

