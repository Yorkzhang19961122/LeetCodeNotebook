【题目】

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

【示例】

![](https://github.com/Yorkzhang19961122/LeetCodeNotebook/blob/main/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/62.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84_M/robot_maze.png)

```c++
输入：m = 3, n = 7
输出：28
```

---

【题解思路—动态规划DP】

* **定义数组的含义**：我们的目的是从左上角到右下角一共有多少条路径，那么我们定义`dp[i][j]`为：当机器人从左上角走到`(i, j)`这个位置时，一共有`dp[i][j]`中路径，那么`dp[m-1][n-1]`就是我们的答案（因为二维数组的下标我们是从0开始计算的）
* **找出`dp`数组中元素间的关系式（`转移方程`）**：由于机器人每次只能**往右**或者**往下**走一步，因此有两种方式到达`(i, j)`这个位置，一种是从`(i-1, j)`走一步到达，另一种是从`(i, j-1)`处走一步到达，所以走到`(i, j)`所有可能路径为`dp[i][j] = dp[i-1][j] + dp[i][j-1]` 
* **确定初始值**：如果i或者j有一个为0，那么我们确定的状态方程就无法使用了，因此我们需要且确定`dp[0][0...n-1]`和`dp[0...m-1][0]`的值，相当于表格中的最上面一行和最左边一列，初始值为下：
  * `dp[0][0...n-1] = 1  //最上面一行，机器人只能一直往右走`
  * `dp[0...m-1][0]  //最左边一列，机器人只能一直往下走`

【题解代码—动态规划DP】

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        //int dp[m][n];  //创建二维数组
        vector<vector<int>> dp(m, vector(n, 0));  //二维数组vector的初始化
        for(int i = 0; i < m; i++) {  //确定左边一列的初始值
            dp[i][0] = 1;
        }
        for(int i = 0; i < n; i++) {  //确定最上面一行的初始值
            dp[0][i] = 1;
        }
        for(int i = 1; i < m; i++) {  //由转移方程得到其他位置需要的步数
            for(int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```



【TIPS】

使用`vector`初始化二维数组的形式（假设初始化一个`m`行，`n`列的二维数组`dp`）：

我们知道一维vector的一种初始化方式：`vector<int> vec(n, 0);  //表示用n个0初始化vec`

有了这个前提，下面的二维vector初始化就很好理解了：

`vector<vector<int>> dp(m, vector<int>(n, 0));   //初始化为m行n列全为0的二维数组`

