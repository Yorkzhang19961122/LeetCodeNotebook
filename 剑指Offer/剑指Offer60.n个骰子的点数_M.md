【题目】

把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

【示例】

```c++
输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
```

```c++
输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
```

---

【[题解思路—动态规划](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/solution/nge-tou-zi-de-dian-shu-dong-tai-gui-hua-ji-qi-yo-3/)】

题目需要我们求出所有点数和出现的概率，根据概率的计算公式，点数和为 *k* 出现概率计算公式为：

`P(k) = 和为k出现的次数/不同点数和的总次数`

投掷 n 个骰子，所有点数和出现的总次数是`6^n`，因为一共有 n 枚骰子，每枚骰子的点数都有 6 种可能出现的情况

我们的目的就是计算出投掷完 n 枚骰子后每个点数和出现的次数。当投完 n 枚骰子时，各个点数和出现的次数即为最后一个阶段

使用二维数组`dp[i][j]`表示状态：

* 数组的第一维`i`来表示阶段，也就是投掷完了几枚骰子
* 用第二维`j`来表示投掷完这些骰子后，可能出现的点数和
* 数组的值就表示，该阶段各个点数和出现的次数

**找状态转移方程**：

最后一个阶段也就是投掷完 n 枚骰子后的这个阶段，我们用 `dp[n][j]` 来表示最后一个阶段点数和 `j` 出现的次数。

只看第 n 枚骰子，它的点数可能为1，2，3，...，6，因此投完 n 枚色子后点数和出现`j`的次数，可以由投完n-1枚色子后，对应点数和`j-1,j-2,j-3,j-4,...,j-6`出现的次数之和转化而来，更详细来说：

* n 个骰子点数和为 s 的种类数只与 n-1 个骰子的和有关。因为一个骰子有六个点数，那么第 n 个骰子可能出现 1 到 6 的点数。所以第 n 个骰子点数为 1 的话，`dp[n][s]=dp[n-1][s-1]`，当第 n 个骰子点数为 2 的话，`dp[n][s]=dp[n-1][s-2]`，…，依次类推。在 n-1 个骰子的基础上，再增加一个骰子出现点数和为 s 的结果只有这 6 种情况！那么有： `dp[n][s] = dp[n-1][s-1]+dp[n-1][s-2]+dp[n-1][s-3]+dp[n-1][s-4]+dp[n-1][s-5]+dp[n-1][s-6]`

**确定初值**：

投掷完 1 枚骰子后，它的可能点数分别为 1, 2, 3, ... , 6，并且每个点数出现的次数都是 1

即当`n=1`时, `dp[1][1] = dp[1][2] = dp[1][3] = ... = dp[1][6] = 1`

【题解代码—动态规划】

```C++
class Solution {
public:
    vector<double> dicesProbability(int n) {
        int dp[15][70];  //初始化dp
        memset(dp, 0, sizeof(dp));  //给dp数组赋初值
        for(int i = 1; i <= 6; i++) {
            dp[1][i] = 1;  //边界条件初始化，一个骰子时点数为1-6出现的次数
        }
        for(int i = 2; i <= n; i++)  //第一层：每多一个骰子
            for(int j = i; j <= 6*i; j++)  //第二层：这么多骰子情况下的所有可能和
                for(int cur = 1; cur <= 6; cur++) {  //第三层：可以从少一个骰子的情况来得到目前的这种可能和（状态转移）
                    if(j - cur < i - 1) break;  //前i-1颗骰子可能出现的点数和 j-cur 最小为i-1（即所有骰子点数都为1），所以j-cur<i-1的情况是不存在的
                    dp[i][j] += dp[i - 1][j - cur];  //状态转移方程
                }

        vector<double> res;
        int all = pow(6, n);  //n个骰子时，所有点数和出现的总次数
        for(int i = n; i <= 6 * n; i++) {  //将n个筛子不同点数和的次数push到res中，并转为double类型
            res.push_back(dp[n][i]*1.0 / all);
            //res.push_back((double)dp[n][i] / all);
        }
        return res;
    }
};
```

每个阶段的状态都只和它前一阶段的状态有关，因此不需要用额外的一维来保存所有阶段，用一维数组来保存一个阶段的状态，然后对下一个阶段可能出现的点数 `j` **从大到小**遍历，实现一个阶段到下一阶段的转换，代码优化如下：

```c++
class Solution {
public:
    vector<double> dicesProbability(int n) {
        int dp[70];
        memset(dp, 0, sizeof(dp));
        for(int i = 1; i <= 6; i++) {  //初始化dp数组
            dp[i] = 1;  //边界条件初始化
        }
        for(int i = 2; i <= n; i++) {  //骰子每增加一个
            for(int j = i*6; j >= i; j--) {  //从大到小倒序
                dp[j] = 0;  //清空原值，防止叠加出错
                for(int cur = 1; cur <= 6; cur++) {
                    if(j - cur < i - 1) break;
                    dp[j] += dp[j - cur];
                }
            }
        }

        vector<double> res;
        int all = pow(6, n);
        for(int i = n; i <= n*6; i++) {
            res.push_back((double)dp[i] / all); 
        }
        return res;
    }
};
```

