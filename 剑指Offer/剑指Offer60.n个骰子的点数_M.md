【题目】

把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

【示例】

```c++
输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
```

```c++
输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
```

---

【题解思路—动态规划】

题目需要我们求出所有点数和出现的概率，根据概率的计算公式，点数和为 *k* 出现概率计算公式为：

`P(k) = 和为k出现的次数/不同点数和的总次数`

投掷 n 个骰子，所有点数和出现的总次数是`6^n`，因为一共有 n 枚骰子，每枚骰子的点数都有 6 种可能出现的情况。

我们的目的就是计算出投掷完n 枚骰子后每个点数和出现的次数。

当投完n枚色子时，各个点数和出现的次数即为最后一个阶段。

使用二维数组`dp[i][j]`表示状态：

* 数组的第一维来表示阶段，也就是投掷完了几枚骰子
* 用第二维来表示投掷完这些骰子后，可能出现的点数和
* 数组的值就表示，该阶段各个点数和出现的次数

**找状态转移方程**：

最后一个阶段也就是投掷完 n 枚骰子后的这个阶段，我们用 `dp[n][j]` 来表示最后一个阶段点数和 `j` 出现的次数。

只看第n枚色子，它的点数可能为1，2，3，...6，因此投完n枚色子后点数和出现`j`的次数，可以由投完n-1枚色子后，对应点数和`j-1,j-2,j-3,j-4,...,j-6`出现的次数之和转化而来：

* n个骰子点数和为s的种类数只与n-1个骰子的和有关。因为一个骰子有六个点数，那么第n个骰子可能出现1到6的点数。所以第n个骰子点数为1的话，f(n,s)=f(n-1,s-1)，当第n个骰子点数为2的话，f(n,s)=f(n-1,s-2)，…，依次类推。在n-1个骰子的基础上，再增加一个骰子出现点数和为s的结果只有这6种情况！那么有：f(n,s)=f(n-1,s-1)+f(n-1,s-2)+f(n-1,s-3)+f(n-1,s-4)+f(n-1,s-5)+f(n-1,s-6)

**确定初值**：

投掷完 1 枚骰子后，它的可能点数分别为 1, 2, 3, ... , 6，并且每个点数出现的次数都是 1.

即当n=1时, `dp[1][1] = dp[1][2] = dp[1][3] = ... = dp[1][6] = 1`

【题解代码—动态规划】

```C++
class Solution {
public:
    vector<double> dicesProbability(int n) {
        int dp[15][70] = {0};
        for(int i = 1; i <= 6; i++) {
            dp[1][i] = 1;  //初始化，一个色子时点数为1-6出现的次数
        }
        for(int i = 2; i <= n; i++)
            for(int j = i; j <= 6*i; j++)
                for(int cur = 1; cur <= 6; cur++) {
                    if(j - cur <= 0) break;
                    dp[i][j] += dp[i - 1][j - cur];
                }

        vector<double> res;
        int all = pow(6, n);
        for(int i = n; i <= 6 * n; i++) {
            res.push_back(dp[n][i]*1.0 / all);
        }
        return res;
    }
};
```

