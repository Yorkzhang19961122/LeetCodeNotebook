【题目】

给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

* 结点左子树中所含结点的值小于等于当前结点的值
* 结点右子树中所含结点的值大于等于当前结点的值
* 左子树和右子树都是二叉搜索树

【示例】

给定 BST `[1,null,2,2]`,

```
   1
    \
     2
    /
   2
```

`返回[2]`.

---

【题解思路1—暴力遍历】

把整个树都遍历了，用 `map` 统计频率，再用 `vector` 排个序，最后返回前面高频的元素。

【题解代码1—暴力遍历】

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
     void recursion(TreeNode* node, unordered_map<int, int>& map){
         //前序遍历
        if(node == NULL) return;
        map[node->val]++;
        recursion(node->left, map);
        recursion(node->right, map);
        return;
    }
    bool static cmp(const pair<int, int>& a, const pair<int, int>& b){  //降序排列
        return a.second > b.second;
    }
    vector<int> findMode(TreeNode* root) {
        vector<int> result;
        unordered_map<int, int> map;  //map用于存储对应节点数值出现的次数
        if(root == NULL) return result;
        recursion(root, map);
        vector<pair<int, int>> vec(map.begin(), map.end());  //vec存储map的值
        sort(vec.begin(), vec.end(), cmp);  //对vec的second按照降序排列
        result.push_back(vec[0].first);  //vec的第一个元素就是出现频率最高的节点值，将其添加到result中
        for(int i = 1; i < vec.size(); ++i){  //可能有出现次数一样多的节点值，继续遍历vec的后面元素，如果和vec[0].second相同，说明同为次数最多的元素值
            if(vec[i].second == vec[0].second) result.push_back(vec[i].first);
            else continue;
        }
        return result;
    }
};
```

