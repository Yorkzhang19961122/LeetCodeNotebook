## 二叉树前中后序遍历（递归和栈模拟）

### 1、前序遍历（[题144]([二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/))）

* 递归

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      vector<int> res;
      vector<int> preorderTraversal(TreeNode* root) {
          preorder(root);
          return res;
      }
      void preorder(TreeNode* root) {
          if(root == nullptr) return;  
          res.push_back(root->val);  //中
          preorder(root->left);  //左
          preorder(root->right);  //右
      }
  };
  ```

* 栈模拟

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      vector<int> preorderTraversal(TreeNode* root) {
          vector<int> res;
          if(root == nullptr) return res;  //判空
          stack<TreeNode*> Stk;
          Stk.push(root);
          while(!Stk.empty()) {
              root = Stk.top();
              Stk.pop();
              res.push_back(root->val);  //中
              if(root->right) Stk.push(root->right);  //右（空节点不入栈），先右后左才能在出栈的时候先左后右
              if(root->left) Stk.push(root->left);  //左（空节点不入栈）
          }
          return res;
      }
  };
  ```

### 2、中序遍历（[题94]([二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/))）

* 递归

  ```
  
  ```

* 栈模拟

  ```
  
  ```

### 3、后序遍历（[题145]([二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/))）

* 递归

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      vector<int> res;
      vector<int> postorderTraversal(TreeNode* root) {
          postorder(root);
          return res;
      }
      void postorder(TreeNode* root) {
          if(root == nullptr) return;  
          postorder(root->left);  //左
          postorder(root->right);  //右
          res.push_back(root->val);  //中
      }
  };
  ```

* 栈模拟（将先序遍历的代码稍作修改即可）

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      vector<int> postorderTraversal(TreeNode* root) {
          vector<int> res;
          if(root == nullptr) return res;
          stack<TreeNode*> Stk;
          Stk.push(root);
          while(!Stk.empty()) {
              root = Stk.top();
              Stk.pop();
              res.push_back(root->val);  //中
              if(root->left) Stk.push(root->left);  //左
              if(root->right) Stk.push(root->right);  //右
          }
          reverse(res.begin(), res.end());  //对结果反转
          return res;
      }
  };
  ```
  
  **先序遍历**：理想：中左右，实际入栈：中右左，出栈得到中左右
  
  **后序遍历**：理想：左右中，实际入栈：中左右，出栈得到中右左，再将其反转`reverse`即可得到最终结果

