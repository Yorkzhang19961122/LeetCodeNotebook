### 排序算法小结

* 一、非线性时间比较类排序
  * 1.1 交换排序
    * [冒泡排序](#1.1.1)
    * [快速排序](#1.1.2)
  * 1.2 插入排序
    * [简单插入排序](#1.2.1)
    * [希尔排序](#1.2.2)
  * 1.3 选择排序
    * [简单选择排序](#1.3.1)
    * [堆排序](#1.3.2)
  * 1.4 归并排序
    * [二路归并排序](#1.4.1)
    * [多路归并排序](#1.4.2)
* 二、线性时间非比较类排序
  * 2.1 [计数排序](#2.1)
  * 2.2 [桶排序](#2.2)
  * 2.3 [基数排序](2.2)

```
背景：给一个整数数组nums，要求将该数组升序或者降序排列。
```

#### <h2 id="1.1.1"> 冒泡排序</h2>

##### 思路：



##### 代码：



#### <h2 id="1.3.1"> 选择排序</h2>

##### 思路：

每一轮选择最小的元素，将其交换到前面未排定部分的开头。

也就是说：对于每一个数`nums[i]`，都要对它及后面所有数进行大小比较，得到后面区间`[i, len - 1]`内最小的数`nums[minIndex]`，再将这两个数进行交换。

##### 代码：

算法：

```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        int len = nums.size();
        //[0,i)有序，且该区间里所有的元素就是最终排定的样子
        for(int i = 0; i < len - 1; i++) {
            //选择区间[i, len - 1]内最小元素的索引，将其与下标i的元素（即未排定部分的开头）交换
            int minIndex = i;
            for(int j = i + 1; j < len; j++) {
                if(nums[j] < nums[minIndex]) {
                    minIndex = j;
                }
            }
            swap(nums[i], nums[minIndex]);
        }
        return nums;
    }
};
```

> 时间复杂度：`O(N^2)`
>
> 空间复杂度：`O(1)`

完整代码：

```C++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
//选择排序
void sortArray(vector<int>& nums) {
    for(int i = 0; i < nums.size() - 1; i++) {
        int minIndex = i;
        for(int j = i + 1; j < nums.size(); j++) {
            if(nums[j] < nums[minIndex]) {
                minIndex = j;
            }
        }
        swap(nums[i], nums[minIndex]);
    }
}
//打印数组
void printArray(vector<int>& nums) {
    for(int i = 0; i < nums.size(); i++) {
        cout << nums[i] << " ";
    }
    cout << endl;
}

int main() {

    vector<int> nums = {5, 5, 6, 1, 3, 4, 7};
    printArray(nums);
    sortArray(nums);
    printArray(nums);

    return 0;
}
```

输出：

```
5 5 6 1 3 4 7 
1 3 4 5 5 6 7 
```

#### <h2 id="1.2.1"> 插入排序</h2>

##### 思路：



##### 代码：

```

```

