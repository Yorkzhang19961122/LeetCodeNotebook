### 排序算法小结

* 一、非线性时间比较类排序
  * 1.1 交换排序
    * [冒泡排序](#1.1.1)
    * [快速排序](#1.1.2)
  * 1.2 插入排序
    * [简单插入排序](#1.2.1)
    * [希尔排序](#1.2.2)
  * 1.3 选择排序
    * [简单选择排序](#1.3.1)
    * [堆排序](#1.3.2)
  * 1.4 归并排序
    * [二路归并排序](#1.4.1)
    * [多路归并排序](#1.4.2)
* 二、线性时间非比较类排序
  * 2.1 [计数排序](#2.1)
  * 2.2 [桶排序](#2.2)
  * 2.3 [基数排序](2.2)

```
背景：给一个整数数组nums，要求将该数组升序或者降序排列。
```



#### <h2 id="1.1.1"> 冒泡排序</h2>

##### 思路：

冒泡排序在扫描过程中两两比较相邻记录，如果反序则交换，最终，最大记录就被“沉到”了序列的最后一个位置，第二遍扫描将第二大记录“沉到”了倒数第二个位置，重复上述操作，直到 `n-1` 遍扫描后，整个序列就排好序了。

##### 代码（默认升序）：

`for(int i = 0; i < n - 1; i++)`：`i`从`0`开始，那么`i`最大能取到`n-2`，总共会遍历`n-1`次

```C++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        int len = nums.size();
        for(int i = 0; i < len - 1; i++) {  //i控制len-1趟冒泡（len-1是因为最后一个数不需要比较，自动就出来了）
            //j控制每趟冒泡时两两比较的下标索引
            //第i趟说明后面已经"沉了"i + 1个数，那么只需要对未排序的数（即len-(i+1)个）进行两两比较即可
            for(int j = 0; j < len - (i + 1); j++) {  
                if(nums[j] > nums[j + 1]) {  //降序：">"改成"<"
                    swap(nums[j], nums[j + 1]);
                }
            }
        }
        return nums;
    }
};
```

> 时间复杂度：`O(N^2)`
>
> 空间复杂度：`O(1)`



<h2 id="1.1.2">快速排序 </h2>

<h2 id="1.3.1"> 选择排序</h2>

##### 思路：

每一轮选择最小的元素，将其交换到前面未排定部分的开头。

也就是说：对于每一个数`nums[i]`，都要对它及后面所有数进行大小比较，得到后面下标区间`[i, len - 1]`内最小的数`nums[minIndex]`，再将这两个数进行交换。

##### 代码（默认升序）：

```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        int len = nums.size();
        //[0,i)有序，且该区间里所有的元素就是最终排定的样子
        for(int i = 0; i < len - 1; i++) {
            //选择区间[i, len - 1]内最小元素的索引，将其与下标i的元素（即未排定部分的开头）交换
            int minIndex = i;
            for(int j = i + 1; j < len; j++) {
                if(nums[j] < nums[minIndex]) {  //降序：将"<"改成">"
                    minIndex = j;
                }
            }
            swap(nums[i], nums[minIndex]);
        }
        return nums;
    }
};
```

> 时间复杂度：`O(N^2)`
>
> 空间复杂度：`O(1)`



#### <h2 id="1.2.1"> 插入排序</h2>

##### 思路：



##### 代码：

```

```

