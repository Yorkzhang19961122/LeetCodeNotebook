<h1> 排序算法小结</h1>

* 一、非线性时间比较类排序
  * 1.1 交换排序
    * [冒泡排序](#1.1.1)
    * [快速排序](#1.1.2)
  * 1.2 插入排序
    * [直接插入排序](#1.2.1)
    * [希尔排序](#1.2.2)
  * 1.3 选择排序
    * [直接选择排序](#1.3.1)
    * [堆排序](#1.3.2)
  * 1.4 归并排序
    * [二路归并排序](#1.4.1)
    * [多路归并排序](#1.4.2)
* 二、线性时间非比较类排序
  * 2.1 [计数排序](#2.1)
  * 2.2 [桶排序](#2.2)
  * 2.3 [基数排序](2.2)

```
背景：给一个整数数组nums，要求将该数组升序或者降序排列。
```



<h2 id="1.1.1"> 冒泡排序</h2>

**思路**：

冒泡排序在扫描过程中两两比较相邻记录，如果反序则交换，最终，最大记录就被“沉到”了序列的最后一个位置，第二遍扫描将第二大记录“沉到”了倒数第二个位置，重复上述操作，直到 `n-1` 遍扫描后，整个序列就排好序了。

**代码（默认升序）**：

`for(int i = 0; i < n - 1; i++)`：`i`从`0`开始，那么`i`最大能取到`n-2`，总共会遍历`n-1`次

```C++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        bubbleSort(nums);
        return nums;
    }
    //冒泡排序的实现
    void bubbleSort(vector<int>& arr) {
        int len = arr.size();
        for(int i = 0; i < len - 1; i++) {  //i控制len-1趟冒泡（len-1是因为最后一个数不需要比较，自然会得到）
            //j控制每趟冒泡时两两比较的下标索引
            //第i趟说明接下来要“沉”第i(+1)个数，那么需要进行两两交换的次数就等于len-1-i
            for(int j = 0; j < len - (i + 1); j++) {  
                if(arr[j] > arr[j + 1]) {  //降序：">"改成"<"
                    swap(arr[j], arr[j + 1]);
                }
            }
        }
    }
};
```

> 时间复杂度：`O(N^2)`
>
> 空间复杂度：`O(1)`



<h2 id="1.1.2">快速排序 </h2>

**思路**：

见[该链接](https://blog.csdn.net/qq_28584889/article/details/88136498)，配合图片

**代码（默认升序）：**

```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        quickSort(0, nums.size() - 1, nums);  //调用快排
        return nums;
    }
    //快排的实现
    void quickSort(int left, int right, vector<int>& arr) {  //left，right为待排序区间的左右边界下标
        if(left > right) return;  //递归终止条件
        int i = left, j = right;  //初始化i，j哨兵
        int base = arr[left];  //初始化base值等于最左边的元素
        while(i < j) {
            //注意两个哨兵移动的先后顺序：哪边初始化为base，就从另一边开始
            while(arr[j] >= base && i < j) {  //哨兵j向左移动，寻找小于base的元素（注意此处的等号）
                j--;
            }
            while(arr[i] <= base && i < j) {  //哨兵i向右移动，寻找大于base的元素
                i++;
            }
            swap(arr[i], arr[j]);  //两个哨兵都找到满足条件的值后，交换两者
        }
        swap(arr[left], arr[i]);  //直至哨兵相遇，将base值归位
        quickSort(left, i - 1, arr);  //递归左子列
        quickSort(i + 1, right, arr);  //递归右子列
    }
};
```

降序排列：只需要修改两个哨兵左右移动条件的不等号即可

> 时间复杂度：O(NlogN)，这里 *N* 是数组的长度
>
> 空间复杂度：O(logN)，这里占用的空间主要来自递归函数的栈空间

<h2 id="1.3.1"> 选择排序</h2>

**思路**：

每一轮选择最小的元素，将其交换到前面未排定部分的开头。

也就是说：对于每一个数`nums[i]`，都要对它及后面所有数进行大小比较，得到后面下标区间`[i, len - 1]`内最小的数`nums[minIndex]`，再将这两个数进行交换。

**代码（默认升序）**：

```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
    	selectSort(nums);
        return nums;
    }
    //选择排序的实现
    void selectSort(vector<int>& arr) {
        int len = arr.size();
        //[0,i)有序，且该区间里所有的元素就是最终排定的样子
        for(int i = 0; i < len - 1; i++) {
            //选择区间[i, len - 1]内最小元素的索引，将其与下标i的元素（即未排定部分的开头）交换
            int minIndex = i;
            for(int j = i + 1; j < len; j++) {
                if(arr[j] < arr[minIndex]) {  //降序：将"<"改成">"
                    minIndex = j;
                }
            }
            swap(arr[i], arr[minIndex]);
        }
    }
};
```

> 时间复杂度：`O(N^2)`
>
> 空间复杂度：`O(1)`



<h2 id="1.2.1"> 插入排序</h2>

**思路**：

1. 从第一个元素`(i=0)`开始，该元素可以认为已被排序，所以`i`从`1`开始；
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描（由`j`控制）；
3. 如果该元素（已排序）大于新元素，将该元素移到下一个位置；
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
5. 将新元素插入到该位置后，重复2~5

**代码（默认升序）**：

```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        selectSort(nums);
        return nums;
    }
	//选择排序的实现
    void selectSort(vector<int>& arr) {
        //i控制遍历插入的轮次，j用来将前面有序的元素后移（i从1开始，默认第一个元素已经排序）
        for(int i = 1; i < arr.size(); i++) {
            //暂存位置i的元素值
            int temp = arr[i];
            int j = i;
            //根据升（降）序将前面的有序数字后移直到j为0 或 找到已排序的元素小于或者等于新元素(temp)的位置
            while(j > 0 && arr[j - 1] > temp) {  //降序只需要改变">"为"<"
                arr[j] = arr[j - 1];
                j--;
            }
            //将（暂存的）待插入元素插入
            arr[j] = temp;
        }
    }
};
```

> 时间复杂度：`O(N^2)`
>
> 空间复杂度：`O(1)`



<h2 id="1.2.2"> 希尔排序</h2>

**[思路](https://blog.csdn.net/Hedenghui777/article/details/113135157)**：

「希尔排序」是对直接插入排序的优化，在直接插入排序里，如果靠后的数字较小，它来到前面就得交换多次。「希尔排序」改进了这种做法。带间隔地使用插入排序，直到最后「间隔」为 1 的时候，就是标准的「插入排序」，此时数组里的元素已经「几乎有序」了

**代码（默认升序）**：

```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        shellSort(nums);
        return nums;
    }

    void shellSort(vector<int>& arr) {
        int len = arr.size();
        int gap = 1;
        //使用knuth增量序列找增量gap的最大值
        while(3 * gap + 1 < len) {
            gap = 3 * gap + 1;
        }
        while(gap >= 1) {
            //按照间隔gap将nums分成不同的组，每个组内进行插入排序
            //直至最后gap为1，所有元素都在同一组中，便是基本的插入排序算法
            for(int i = gap; i < len; i++) {
                insertByGap(arr, gap, i);
            }
            gap = gap / 3;
        }
    }
	//和插入排序类似，只不过将nums[i]插入到对应分组的正确位置上（与gap相关）
    void insertByGap(vector<int>& arr, int gap, int i) {
        int temp = arr[i];
        int j = i;
        while(j >= gap && arr[j - gap] > temp) {  //降序只要将">"改成"<"即可
            arr[j] = arr[j - gap];
            j -=gap;
        }
        arr[j] = temp;
    }
};
```

> 时间复杂度：根据增量序列的不同而不同
>
> 空间复杂度：O(1)

