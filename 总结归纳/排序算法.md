<h1> 排序算法小结</h1>

* 一、非线性时间比较类排序
  * 1.1 交换排序
    * [冒泡排序](#1.1.1)
    * [快速排序](#1.1.2)
  * 1.2 插入排序
    * [简单插入排序](#1.2.1)
    * [希尔排序](#1.2.2)
  * 1.3 选择排序
    * [简单选择排序](#1.3.1)
    * [堆排序](#1.3.2)
  * 1.4 归并排序
    * [二路归并排序](#1.4.1)
    * [多路归并排序](#1.4.2)
* 二、线性时间非比较类排序
  * 2.1 [计数排序](#2.1)
  * 2.2 [桶排序](#2.2)
  * 2.3 [基数排序](2.2)

```
背景：给一个整数数组nums，要求将该数组升序或者降序排列。
```



<h2 id="1.1.1"> 冒泡排序</h2>

**思路**：

冒泡排序在扫描过程中两两比较相邻记录，如果反序则交换，最终，最大记录就被“沉到”了序列的最后一个位置，第二遍扫描将第二大记录“沉到”了倒数第二个位置，重复上述操作，直到 `n-1` 遍扫描后，整个序列就排好序了。

**代码（默认升序）**：

`for(int i = 0; i < n - 1; i++)`：`i`从`0`开始，那么`i`最大能取到`n-2`，总共会遍历`n-1`次

```C++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        bubbleSort(nums);
        return nums;
    }
    //冒泡排序的实现
    void bubbleSort(vector<int>& arr) {
        int len = arr.size();
        for(int i = 0; i < len - 1; i++) {  //i控制len-1趟冒泡（len-1是因为最后一个数不需要比较，自然会得到）
            //j控制每趟冒泡时两两比较的下标索引
            //第i趟说明接下来要“沉”第i(+1)个数，那么需要进行两两交换的次数就等于len-1-i
            for(int j = 0; j < len - (i + 1); j++) {  
                if(arr[j] > arr[j + 1]) {  //降序：">"改成"<"
                    swap(arr[j], arr[j + 1]);
                }
            }
        }
    }
};
```

> 时间复杂度：`O(N^2)`
>
> 空间复杂度：`O(1)`



<h2 id="1.1.2">快速排序 </h2>

**思路**：

见[该链接](https://blog.csdn.net/qq_28584889/article/details/88136498)，配合图片

**代码（默认升序）：**

```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        quickSort(0, nums.size() - 1, nums);  //调用快排
        return nums;
    }
    //快排的实现
    void quickSort(int left, int right, vector<int>& arr) {  //left，right为待排序区间的左右边界下标
        if(left > right) return;  //递归终止条件
        int i = left, j = right;  //初始化i，j哨兵
        int base = arr[left];  //初始化base值等于最左边的元素
        while(i < j) {
            //注意两个哨兵移动的先后顺序：哪边初始化为base，就从另一边开始
            while(arr[j] >= base && i < j) {  //哨兵j向左移动，寻找小于base的元素（注意此处的等号）
                j--;
            }
            while(arr[i] <= base && i < j) {  //哨兵i向右移动，寻找大于base的元素
                i++;
            }
            swap(arr[i], arr[j]);  //两个哨兵都找到满足条件的值后，交换两者
        }
        swap(arr[left], arr[i]);  //直至哨兵相遇，将base值归位
        quickSort(left, i - 1, arr);  //递归左子列
        quickSort(i + 1, right, arr);  //递归右子列
    }
};
```

降序排列：只需要修改两个哨兵左右移动条件的不等号即可

> 时间复杂度：O(NlogN)，这里 *N* 是数组的长度
>
> 空间复杂度：O(logN)，这里占用的空间主要来自递归函数的栈空间

<h2 id="1.3.1"> 选择排序</h2>

**思路**：

每一轮选择最小的元素，将其交换到前面未排定部分的开头。

也就是说：对于每一个数`nums[i]`，都要对它及后面所有数进行大小比较，得到后面下标区间`[i, len - 1]`内最小的数`nums[minIndex]`，再将这两个数进行交换。

**代码（默认升序）**：

```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
    	selectSort(nums);
        return nums;
    }
    //选择排序的实现
    void selectSort(vector<int>& arr) {
        int len = arr.size();
        //[0,i)有序，且该区间里所有的元素就是最终排定的样子
        for(int i = 0; i < len - 1; i++) {
            //选择区间[i, len - 1]内最小元素的索引，将其与下标i的元素（即未排定部分的开头）交换
            int minIndex = i;
            for(int j = i + 1; j < len; j++) {
                if(arr[j] < arr[minIndex]) {  //降序：将"<"改成">"
                    minIndex = j;
                }
            }
            swap(arr[i], arr[minIndex]);
        }
    }
};
```

> 时间复杂度：`O(N^2)`
>
> 空间复杂度：`O(1)`



<h2 id="1.2.1"> 插入排序</h2>

**思路**：



**代码**：

```

```

