【题目】

给你一个字符串 s ，请你根据下面的算法重新构造字符串：

> 1.从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。  
> 2.从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。  
> 3.重复步骤 2 ，直到你没法从 s 中选择字符。  
> 4.从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。  
> 5.从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。  
> 6.重复步骤 5 ，直到你没法从 s 中选择字符。  
> 7.重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。  

在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。  

请你返回将 s 中字符重新排序后的 结果字符串 。

【示例】

>输入：s = "aaaabbbbcccc"  
>输出："abccbaabccba"  

解释：第一轮的步骤 1，2，3 后，结果字符串为 result = "abc"  
第一轮的步骤 4，5，6 后，结果字符串为 result = "abccba"  
第一轮结束，现在 s = "aabbcc" ，我们再次回到步骤 1  
第二轮的步骤 1，2，3 后，结果字符串为 result = "abccbaabc"  
第二轮的步骤 4，5，6 后，结果字符串为 result = "abccbaabccba"

---

【题解思路—桶记数】

开一个长度为26的数字表示26个桶，每个桶里存放一种字母出现的次数，然后我们只需要不停的扫描这个“桶序列”——先从小到大扫描，再从大到小扫描，每次发现某一个桶中的值不为0时，就把这个桶对应的字母添加到结果字符串的末尾，然后对其桶计数值减1

【题解代码—桶记数】

```c++
class Solution {
public:
    string sortString(string s) {
        vector<int> h(26, 0);
        for(auto &c : s) ++h[c - 'a'];  //遍历字符串s，将每个字母出现的次数按字母表顺序存在数组h中
        string ans;
        auto appendChar = [&] (int p){  //appendChar函数用于遍历每个桶时添加最大/最小的字符到ans中
            if(h[p]){  //如果h数组中某个桶不为0
                ans.push_back(p + 'a');  //将这个桶代表的字母添加一个到ans中
                --h[p];  //该桶内的数量减1
            }
        };
        while(1){
            if(ans.size() == s.size()) break;  //如果存放结果的字符串ans长度等于s，则说明所有的数据都处理完毕
            for(int i = 0; i < 26; ++i) appendChar(i);  //正向遍历h，从小到大获得字符
            for(int i = 25; i >= 0; --i) appendChar(i);  //逆向遍历，从大到小获得字符
        }
        return ans;
    }
};
```

注意，代码中：

```c++
auto appendChar = [&] (int p){  //appendChar函数用于遍历每个桶时添加最大/最小的字符到ans中
            if(h[p]){  //如果h数组中某个桶不为0
                ans.push_back(p + 'a');  //将这个桶代表的字母添加一个到ans中
                --h[p];  //该桶内的数量减1
            }
        };
```

使用了C++11 的**Lambda表达式（匿名函数）**,Lambda表达式的定义形式如下：

```
[外部变量访问方式说明符](参数表) -> 返回值类型
{
    语句块
}
```

其中，“外部变量访问方式说明符”可以是`=`或`&`，该说明符表示在`{}`中用到的，定义在`{}`外面的变量在`{}`中是否允许被改变，`=`表示不允许，`&`表示允许，当然在`{}`中也可以不使用定义在外面的变量。“-> 返回值类型”可以省略。而`auto appendChar`则允许我们像调用函数一样使用Lambda表达式，有关Lambda表达式更详细的内容见[此链接](http://c.biancheng.net/view/433.html)。

