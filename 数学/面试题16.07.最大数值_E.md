【题目】

编写一个方法，找出两个数字a和b中最大的那一个。不得使用`if-else`或其他比较运算符。

【示例】

> 输入： a = 1, b = 2  
> 输出： 2

---

【题解思路】

在数学上对于两个数的最大值，有下面的等式，Max(a,b)=(|a-b|+a+b)/2，我们可以直接使用这个等式得到最大值，不过我们需要注意的是，因为在进行加减的过程中数字可能会过大溢出，导致结果错误，所以我们还应该将int转话为long或者double来防止溢出

【题解代码】

```c++
class Solution {
public:
    int maximum(int a, int b) {
        long c = a;  //int转为long防止溢出
        long d = b;
        int ans = (int) ((fabs(c-d)+c+d)/2);
        return ans;
    }
};
```

值得注意的是，abs函数的实现往往采用以下的方式：

```c++
public static long abs(long a){
	return a > 0 ? a : -a;
}
```

这样的实现也有比较符号，所以，abs的实现可以采用如下方法：

```c++
long absolute(long a) {
        int flag = a >> 63;  //正数flag = 0，负数flag = -1
        return (flag ^ a) - flag;  //任何数与0异或值不变，任何数与-1异或等价于按位取反
    }
```

代码中`a >> 63`后，假如a是正数，flag = 0，a是负数，flag = -1（过程：假如a=1（`0000 0001`），向右移动63，变为`0000 0000`，即0，而假如a=-1（`1000 0001`），向右移动63，变为`1111 1111`，即-1（过程在下面tips中））

【Tips】

（1）原码补码和ASCII码：

ASCII码有限，它用来表示常用字符的，比如‘a', '1', '#' 等等，比如字符'1'的ASCII码就是1（注意这里的'1'是指'字符1），字符'a'的ASCII码是97。至于计算机运算过程所使用的正负数，涉及到'原码反码补码'，而不是ASCII码。

**例如：**

12的原码反码补码都一样：`0000 1100`（12的二进制）

-12的原码反码补码都是通过12的原码来求解的：

-12的原码：`1000 1100`（最左边的数字表示符号，0为正，1为负。求-12的原码直接取反12原码最左边的数字就行）

-12的反码：`1111 0011`（12原码上的所有数字全部取反）

-12的补码：`1111 0100`（在-12的反码上加1）

（2）`>>`

右移运算符，`a >> b`表示将a的所有位向右移b指定的位数，a的符号位被用来填充右移后左边空出来的位，向右移出的位则被丢弃。

**例如：**

`-14 >> 2 = -4`，-14二进制表示为`1111 0010`（负数通常用补码表示，14的二进制是`0000 1110`，-14的二进制原码是`1000 1110`，-14反码是`1111 0001`，则-14的补码是`1111 0010`，用以表示-14），向右移动两位后得到`1111 1100`（即-4，过程：`1111 1100`先减1，得到`1111 1011`，再取反得到`1000 0100`，即-4）

【TODO】

位运算解法