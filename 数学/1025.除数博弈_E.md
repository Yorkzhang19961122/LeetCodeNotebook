【题目】

爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。

最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：

> 选出任一 x，满足 0 < x < N 且 N % x == 0 。  
> 用 N - x 替换黑板上的数字 N 。  
> 如果玩家无法执行这些操作，就会输掉游戏。  

只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 False。假设两个玩家都以最佳状态参与游戏。

【示例】

> 输入：2  
> 输出：true  
> 解释：爱丽丝选择 1，鲍勃无法进行操作。  

> 输入：3  
> 输出：false  
> 解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。

---

【题解思路1—找规律】

博弈类问题尝试找规律：

（1）N=1时，(0, 1)内没有整数是n的因数，此时Alice败

（2）N=2时，Alice拿1，N变为1，Bob无法继续操作，此时Bob败

（3）N=3时，Alice拿1，N变为2，根据N=2的情况，此时Alice败

（4）N=4时，Alice拿1或2，如果拿1，N变为3，根据N=3的情况，此时Bob败（不能拿2，因为两人都处在最佳状态，拿2会导致Alice失败）

（5）N=5时，Alice拿1，N变为4，根据N=4的情况，此时Alice败

......

依此类推，猜想N为奇数的时候Alice（先手）必败，N为偶数时Alice必胜

【题解代码1—找规律】

```c++
class Solution {
public:
    bool divisorGame(int N) {  
        return N % 2 == 0;
    }
};
```

【题解思路2—动态规划】

动态规划的几个关键子目标：

（1）建立状态转移方程

（2）缓存并复用以往结果（使用数组记录中间结果）

（3）按顺序从小往大计算（使用for循环依次计算）

对于本题目，我们首先寻找动态规划中的“状态转移方程”和“base case”，base case为：

```c++
dp[0] = false;
dp[1] = false;  //先手者必输
dp[2] = true;  //x=1，先手者必胜
```

而本题中状态只有两个：true或false，我们新建一个数组dp来存放中间计算结果，dp的范围为N+1，

我们定义dp[i]表示当N为i时，当前先手者能够获胜，

因为A先手，所以dp[N]表示A是否能够获胜，而dp[N]则由dp[N-x]决定（因为选手默认会做出使自己获胜的选择，所以当dp[N-x]为false时，当前选手一定会选择这个x，从而使dp[N]为true）

例如：我们已经知道dp[0]，dp[1]，dp[2]的结果，当N=3时，Alice选择x=1，此时N=N-x=3-1=2，根据之前的结论，我们可以知道：对于此时的先手者（Bob），dp[2]=true，即Bob会取得胜利，那么Alice就输了，即对于N=3，dp[3] = false，

继续，

当N=4时，Alice取x为1，此时N=N-x=4-1=3，而dp[3]为false，即接下来轮到Bob操作时，Bob必输，那么Alice在本轮（N=4）就取胜了，即dp[4]=true.（这里需要注意Alice为什么不能将x取2呢？因为若x=2，N=N-x=4-2=2，由于dp[2]=true，说明接下来轮到Bob操作时，他必胜，那么Alice就输了，而题目中说明了双方都以最佳状态参加游戏，也就是说双方不会优先选择到使自己输的x，所以Alice此时只会选择x=1）

通过分析，我们可以得出状态方程：

```c++
dp[i] = true {i % j == 0 && dp[i-j] == false}  //j(x)需要将i(N)整除，并且dp[i-j](dp[N-x])是false，即接下来操作的人必输，那么此时dp[i]就必胜
dp[i] = false {i % j != 0 || dp[i-j] == true}  //我们可以用false初始化dp[]，那么只需要找true即可
```

最后只要使用for循环遍历3-N以及其因数即可：

```c++
//遍历
for(int i = 3; i <= N; ++i){
	for(int j = 1; j < i; ++j){
        ......
    }
}
```

【题解代码2—动态规划】

```c++
class Solution {
public:
    bool divisorGame(int N) {
        vector<bool> dp(N+1, false);  //用N+1个false初始化dp数组
        dp[0] = false;
        dp[1] = false;
        dp[2] = true;  //base case
        for(int i = 3; i <= N; ++i){  //对于N，遍历得到3-N时的结果，将其缓存并复用
            for(int j = 1; j < i; ++j){  //对于每个小于等于N的数，再遍历寻找因数
                if(i % j == 0 && !dp[i-j]){  //如果找到能整除的因数x，且N-x后的结果为false
                    dp[i] = true;  //说明此时的‘N’(i)能让先手者获胜
                    break;
                }
            }
        }
        return dp[N];
    }
};
```

