【题目】

RGB 颜色用十六进制来表示的话，每个大写字母都代表了某个从 0 到 f 的 16 进制数。

RGB 颜色 "#AABBCC" 可以简写成 "#ABC" 。例如，"#15c" 其实是 "#1155cc" 的简写。

现在，假如我们分别定义两个颜色 "#ABCDEF" 和 "#UVWXYZ"，则他们的相似度可以通过这个表达式 -(AB - UV)^2 - (CD - WX)^2 - (EF - YZ)^2 来计算。

那么给定颜色 "#ABCDEF"，请你返回一个与 #ABCDEF 最相似的 7 个字符代表的颜色，并且它是可以被简写形式表达的。（比如，可以表示成类似 "#XYZ" 的形式）

【示例】

> 输入：color = "#09f166"  
> 输出："#11ee66"  
> 解释：   
> 因为相似度计算得出 -(0x09 - 0x11)^2 -(0xf1 - 0xee)^2 - (0x66 - 0x66)^2 = -64 -9 -0 = -73  
> 这已经是所有可以简写的颜色中最相似的了

---

【题解思路1—独立性+枚举】

我们可以发现，颜色中的每一维都是独立的，因此我们只需要分别计算出 `color = #ABCDEF` 中与 `AB`，`CD` 和 `EF` 相似度最大的颜色即可。最终的答案为这三个颜色的结合。

对于 `AB`，我们要在 `00` 到` ff` 中找到一个相似度最大的。而`00` 到 `ff `均为 17 的倍数，因此我们需要找到一个 17 的倍数，使得其与 `AB` 的差的绝对值最小。显然，当 `AB mod 17 > 8` 时，取刚好比 `AB `大的那个数；当 `AB mod 17 <= 8 `时，取刚好比` AB` 小或与 `AB` 相等的那个数。

【题解代码1—独立性+枚举】

```c++
class Solution {
public:
    string similarRGB(string color) {
        return "#" + func(color.substr(1, 2)) + func(color.substr(3, 2)) + func(color.substr(5, 2));  //color.substr(1, 2)：返回color中从1开始的2个字符的拷贝
    }
    string func(string str) {
        string dict = "0123456789abcdef";
        int num = stoi(str, nullptr, 16);  //stoi将十六进制的str转化为十进制
        int idx = num / 17 + (num % 17 > 8 ? 1 : 0);  //通过计算找到与AB差值最小的数
        return string(2, dict[idx]);  //返回“dict[idx]dict[idx]”
    }
};
```

【TIPS】

（1）C++中`substr()`函数的用法

* 用途：`substr(`)是一种构造`string`的方法
* 形式：`s.substr(pos, n)`
* 解释：该函数返回一个`string`，包含`s`中从`pos`开始的`n`个字符的拷贝（`pos`的默认值是0，`n`的默认值是`s.size() - pos`，即不加参数会默认拷贝整个`s`）
* 补充：若`pos`的值超过了`string`的大小，则`substr`函数会抛出一个`out_of_range`异常；若`pos+n`的值超过了`string`的大小，则`substr`会调整`n`的值，只拷贝到`string`的末尾

（2）[C++字符串转换之`stoi`](https://blog.csdn.net/baidu_34884208/article/details/88342844)

```c++
int stoi (const string&  str, size_t* idx = 0, int base = 10);
int stoi (const wstring& str, size_t* idx = 0, int base = 10);
```

* 用途：解析str的文本转化为为int整数（具体用法见本题代码）

* 参数：
* **str**：表示所要转化的字符串 
* **idx**：表示想要str中开始转化的位置，默认为从第一个字符开始（此参数是空指针(**nullptr**)）
* **base**：表示要用的进制（如2进制、16进制，默认为10进制）转化为int类型十进制数字

（3）string(2, 'A')指的是用2个'A'初始化